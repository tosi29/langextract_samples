<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>JSONL Viewer</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 1.5rem; }
    pre { background: #f8f8f8; padding: 1rem; border-radius: 6px; overflow: auto; }
    .entry { margin-bottom: 1rem; border: 1px solid #ddd; border-radius: 6px; padding: 0.75rem; background: #fff; }
    .error { color: #b00020; }
    a { color: #0b57d0; }
    header { margin-bottom: 1.5rem; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 1.5rem; }
    th, td { border: 1px solid #ccc; padding: 0.5rem; text-align: left; vertical-align: top; }
    th { background: #f5f5f5; }
    caption { text-align: left; font-weight: bold; margin-bottom: 0.5rem; }
    tbody tr:nth-child(even) { background: #fafafa; }
    td div { margin: 0.15rem 0; }
  </style>
</head>
<body>
  <header>
    <h1>JSONL Viewer</h1>
    <p>Showing contents of <code id="file-name"></code></p>
    <p><a href="index.html">Back to outputs index</a></p>
  </header>
  <div id="content"></div>
  <script>
    (() => {
      const params = new URLSearchParams(window.location.search);
      const file = params.get("file");
      const inlineData = params.get("data");
      const fileNameEl = document.getElementById("file-name");
      const contentEl = document.getElementById("content");
      const base64ToBytes = (base64) =>
        Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));

      const renderEntries = (text) => {
        if (!text || !text.trim()) {
          contentEl.innerHTML = "<p>No data in this JSONL file.</p>";
          return;
        }
        const lines = text.trim().split(/\n+/);
        const parsedDocs = [];
        const listContainer = document.createElement("div");
        lines.forEach((line, idx) => {
          const entry = document.createElement("div");
          entry.className = "entry";
          const header = document.createElement("strong");
          header.textContent = "Entry " + (idx + 1);
          const pre = document.createElement("pre");
          try {
            const parsed = JSON.parse(line);
            parsedDocs.push(parsed);
            pre.textContent = JSON.stringify(parsed, null, 2);
          } catch (err) {
            pre.textContent = line;
            pre.classList.add("error");
          }
          entry.appendChild(header);
          entry.appendChild(pre);
          listContainer.appendChild(entry);
        });

        const table = buildExtractionTable(parsedDocs);
        contentEl.innerHTML = "";
        if (table) {
          contentEl.appendChild(table);
        }
        contentEl.appendChild(listContainer);
      };

      const buildExtractionTable = (documents) => {
        const rows = [];
        documents.forEach((doc, docIndex) => {
          const extractions = Array.isArray(doc.extractions)
            ? doc.extractions
            : [];
          extractions.forEach((extraction, extractionIndex) => {
            rows.push({
              idx: extractionIndex + 1,
              cls: extraction.extraction_class || "-",
              text: extraction.extraction_text || "-",
              attributes: formatAttributes(extraction.attributes),
            });
          });
        });
        if (!rows.length) {
          return null;
        }
        const table = document.createElement("table");
        table.innerHTML = `
          <thead>
            <tr>
              <th>#</th>
              <th>Extraction Class</th>
              <th>Extraction Text</th>
              <th>Attributes</th>
            </tr>
          </thead>
        `;
        const tbody = document.createElement("tbody");
        rows.forEach((row) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${row.idx}</td>
            <td>${escapeHtml(row.cls)}</td>
            <td>${escapeHtml(row.text)}</td>
            <td>${row.attributes}</td>
          `;
          tbody.appendChild(tr);
        });
        table.prepend(document.createElement("caption"));
        table.caption.textContent = "Structured Extractions";
        table.appendChild(tbody);
        return table;
      };

      const escapeHtml = (value) => {
        const span = document.createElement("span");
        span.textContent = value ?? "";
        return span.innerHTML || " ";
      };

      const formatAttributes = (attributes) => {
        if (!attributes || typeof attributes !== "object") {
          return "-";
        }
        const entries = Object.entries(attributes);
        if (!entries.length) {
          return "-";
        }
        return entries
          .map(
            ([key, value]) =>
              `<div><strong>${escapeHtml(key)}:</strong> ${escapeHtml(
                String(value)
              )}</div>`
          )
          .join("");
      };

      const showError = (message) => {
      contentEl.innerHTML = "<p class='error'>" + message + "</p>";
    };

      if (!file) {
      fileNameEl.textContent = "(no file selected)";
      showError("Specify ?file=<jsonl name> to view content.");
      return;
    }

      fileNameEl.textContent = file;
      if (inlineData) {
        try {
          renderEntries(
            new TextDecoder("utf-8").decode(base64ToBytes(inlineData))
          );
          return;
      } catch (err) {
        console.error(err);
      }
    }

    fetch(file)
      .then((resp) => {
        if (!resp.ok) throw new Error("Failed to load " + file);
        return resp.text();
      })
      .then(renderEntries)
      .catch((err) => {
        showError(err.message + "<br/>Open via docs/index.html for inline preview.");
      });
    })();
  </script>
</body>
</html>
